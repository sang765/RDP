name: Windows VNC Remote Desktop
run-name: Windows VNC Session by ${{ github.actor }}

on:
  workflow_dispatch:

permissions:
  contents: write
  actions: write
  packages: write

env:
  VNC_PASSWORD: ${{ secrets.VNC_PASSWORD }}
  WINDOWS_USER: ${{ secrets.WINDOWS_USER || 'githubrunner' }}

jobs:
  setup-windows-vnc:
    runs-on: windows-latest
    timeout-minutes: 420

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4.1.1

      - name: Mask sensitive values
        shell: pwsh
        run: |
          echo "::add-mask::${{ secrets.VNC_PASSWORD }}"
          echo "::add-mask::${{ secrets.NGROK_AUTH_TOKEN }}"
          echo "::add-mask::${{ secrets.PAT }}"

      - name: Get previous successful workflow run ID
        id: get_previous_run
        shell: pwsh
        run: |
          $url = "https://api.github.com/repos/${{ github.repository }}/actions/runs?status=success&event=workflow_dispatch&per_page=1"
          $headers = @{
            'Authorization' = "token ${{ secrets.PAT }}"
            'Accept'        = 'application/vnd.github.v3+json'
          }
          try {
            $response = Invoke-RestMethod -Uri $url -Headers $headers -Method Get
            if ($response.workflow_runs.Count -gt 0) {
              $runId = $response.workflow_runs[0].id
              Write-Output "Previous successful run ID: $runId"
              echo "prev_run_id=$runId" >> $env:GITHUB_OUTPUT
            } else {
              Write-Output "No previous successful run found."
              echo "prev_run_id=0" >> $env:GITHUB_OUTPUT
            }
          } catch {
            Write-Output "Error fetching previous run: $($_.Exception.Message)"
            echo "prev_run_id=0" >> $env:GITHUB_OUTPUT
          }
        env:
          PAT: ${{ secrets.PAT }}

      - name: Download backup from previous run
        uses: actions/download-artifact@v4.1.1
        with:
          name: windows-backup
          run-id: ${{ steps.get_previous_run.outputs.prev_run_id }}
          path: C:\
        continue-on-error: true

      - name: Restore backup
        shell: pwsh
        run: |
          if (Test-Path "C:\backup.zip") {
            Expand-Archive -Path "C:\backup.zip" -DestinationPath "C:\" -Force
            Remove-Item "C:\backup.zip" -Force
            Write-Output "Backup restored successfully"
          } else {
            Write-Output "No backup found, starting fresh"
          }

      - name: Create local admin user
        shell: pwsh
        run: |
          $username = "$env:WINDOWS_USER"
          
          if (-not (Get-LocalUser -Name $username -ErrorAction SilentlyContinue)) {
            $password = ConvertTo-SecureString "SecurePassword123!" -AsPlainText -Force
            New-LocalUser -Name $username -Password $password -FullName "GitHub Runner" -Description "Temporary admin user for VNC"
            Add-LocalGroupMember -Group "Administrators" -Member $username
            Write-Output "Created user: $username"
          } else {
            Write-Output "User $username already exists"
          }

      - name: Disable Windows Firewall
        shell: pwsh
        run: |
          Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False

      - name: Install TightVNC
        shell: pwsh
        run: |
          try {
            choco install tightvnc -y --force
            Write-Output "TightVNC installed successfully via Chocolatey"
          } catch {
            Write-Error "Failed to install TightVNC: $($_.Exception.Message)"
            exit 1
          }

      - name: Set VNC password
        shell: pwsh
        env:
          VNC_PASSWORD: "${{ secrets.VNC_PASSWORD }}"
        run: |
          $vncPasswdPath = "$env:ProgramFiles\TightVNC\tvnserver.exe"
          if (Test-Path $vncPasswdPath) {
            & "$vncPasswdPath" -controlservice -password $env:VNC_PASSWORD
            Write-Output "VNC password set successfully"
          } else {
            $altPath = "${env:ProgramFiles(x86)}\TightVNC\tvnserver.exe"
            if (Test-Path $altPath) {
              & "$altPath" -controlservice -password $env:VNC_PASSWORD
              Write-Output "VNC password set successfully from alternative path"
            } else {
              Write-Error "TightVNC not found"
            }
          }

      - name: Configure TightVNC Server
        shell: pwsh
        run: |
          $vncServerPath = "$env:ProgramFiles\TightVNC\tvnserver.exe"
          if (Test-Path $vncServerPath) {
            & "$vncServerPath" -install -silent
            & "$vncServerPath" -controlservice -sharedisplay 1
            & "$vncServerPath" -controlservice -allowloopback 1
            Write-Output "TightVNC service installed and configured"
          } else {
            $altPath = "${env:ProgramFiles(x86)}\TightVNC\tvnserver.exe"
            if (Test-Path $altPath) {
              & "$altPath" -install -silent
              & "$altPath" -controlservice -sharedisplay 1
              & "$altPath" -controlservice -allowloopback 1
              Write-Output "TightVNC service installed from alternative path"
            } else {
              Write-Error "TightVNC not found"
            }
          }

      - name: Start TightVNC Server
        shell: pwsh
        run: |
          try {
            Start-Service -Name "tvnserver"
            Start-Sleep -Seconds 5
            $service = Get-Service -Name "tvnserver"
            if ($service.Status -eq "Running") {
              Write-Output "TightVNC server started successfully"
            } else {
              Write-Error "TightVNC service failed to start"
            }
          } catch {
            Write-Error "Failed to start TightVNC service: $($_.Exception.Message)"
          }

      - name: Test VNC connection locally
        shell: pwsh
        run: |
          try {
            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $result = $tcpClient.BeginConnect("127.0.0.1", 5900, $null, $null)
            $success = $result.AsyncWaitHandle.WaitOne(5000)
            if ($success) {
              $tcpClient.EndConnect($result)
              Write-Output "VNC server is responding on localhost"
              echo "vnc_local_test=success" >> $env:GITHUB_OUTPUT
            } else {
              Write-Output "VNC server is not responding on localhost"
              echo "vnc_local_test=failed" >> $env:GITHUB_OUTPUT
            }
            $tcpClient.Close()
          } catch {
            Write-Output "Error testing VNC connection: $($_.Exception.Message)"
            echo "vnc_local_test=error" >> $env:GITHUB_OUTPUT
          }
        id: vnc_test

      - name: Install Ngrok
        shell: pwsh
        run: |
          try {
              $ngrokZip = "C:\ngrok.zip"
              $ngrokDir = "C:\ngrok"

              # Try primary download URL
              try {
                  Invoke-WebRequest -Uri "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip" -OutFile $ngrokZip -TimeoutSec 30
                  Write-Output "Downloaded Ngrok from primary URL"
              } catch {
                  Write-Output "Primary URL failed, trying alternative..."
                  # Alternative download URL
                  Invoke-WebRequest -Uri "https://ngrok.com/download/windows" -OutFile $ngrokZip -TimeoutSec 30
                  Write-Output "Downloaded Ngrok from alternative URL"
              }

              # Extract
              if (Test-Path $ngrokZip) {
                  Expand-Archive -Path $ngrokZip -DestinationPath $ngrokDir -Force
                  Write-Output "Ngrok extracted successfully"
              } else {
                  throw "Download failed - zip file not found"
              }

              # Verify installation
              if (Test-Path "$ngrokDir\ngrok.exe") {
                  Write-Output "Ngrok installed successfully at: $ngrokDir\ngrok.exe"
                  # Test version
                  & "$ngrokDir\ngrok.exe" --version
              } else {
                  throw "Ngrok executable not found after extraction"
              }
          } catch {
              Write-Error "Failed to install Ngrok: $($_.Exception.Message)"
              exit 1
          }
          
      - name: Verify Ngrok installation
        shell: pwsh
        run: |
          $ngrokDir = "C:\ngrok"
          if (Test-Path "$ngrokDir\ngrok.exe") {
              Write-Output "✓ Ngrok executable found"
              # Test chạy ngrok version
              & "$ngrokDir\ngrok.exe" --version
              Write-Output "✓ Ngrok version check passed"
          } else {
              Write-Error "✗ Ngrok executable not found"
              exit 1
          }

      - name: Configure Ngrok
        shell: pwsh
        env:
          NGROK_AUTH_TOKEN: "${{ secrets.NGROK_AUTH_TOKEN }}"
        run: |
          # Thêm đường dẫn ngrok vào PATH cho phiên hiện tại
          $ngrokDir = "C:\ngrok"
          $env:Path += ";$ngrokDir"

          # Kiểm tra ngrok có tồn tại không
          if (Test-Path "$ngrokDir\ngrok.exe") {
              Write-Output "Ngrok found at: $ngrokDir\ngrok.exe"

              # Stop any existing ngrok processes
              Get-Process -Name "ngrok" -ErrorAction SilentlyContinue | Stop-Process -Force

              # Configure authtoken
              $authtokenOutput = & "$ngrokDir\ngrok.exe" authtoken $env:NGROK_AUTH_TOKEN 2>&1
              Write-Output "Authtoken output: $authtokenOutput"

              if ($LASTEXITCODE -ne 0) {
                  Write-Error "Failed to set authtoken. Please verify NGROK_AUTH_TOKEN is valid."
                  exit 1
              }

              Write-Output "Ngrok authtoken configured successfully"

              # Verify config
              $configOutput = & "$ngrokDir\ngrok.exe" config check 2>&1
              Write-Output "Config check output: $configOutput"

              if ($LASTEXITCODE -ne 0) {
                  Write-Error "Config check failed. Authtoken may be invalid."
                  exit 1
              }

              Write-Output "Ngrok config verified"

              # Test authtoken by starting agent briefly
              Write-Output "Testing authtoken by starting ngrok agent..."
              Start-Process -FilePath "C:\ngrok\ngrok.exe" -ArgumentList "start --none --log=stdout" -WindowStyle Hidden
              Start-Sleep -Seconds 5

              try {
                  $testResponse = Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -UseBasicParsing -TimeoutSec 5
                  Write-Output "✓ Authtoken test successful - agent can communicate with ngrok service"
              } catch {
                  Write-Output "⚠ Authtoken test failed: $($_.Exception.Message)"
                  Write-Output "This may indicate an invalid NGROK_AUTH_TOKEN or network issues"
              }

              # Stop the test agent
              Get-Process -Name "ngrok" -ErrorAction SilentlyContinue | Stop-Process -Force

          } else {
              Write-Error "Ngrok executable not found in $ngrokDir"
              exit 1
          }

      
      - name: Verify Ngrok connectivity
        shell: pwsh
        run: |
          $env:Path += ";C:\ngrok"
    
          # Test ngrok version
          & "C:\ngrok\ngrok.exe" --version
          Write-Output "✓ Ngrok version check passed"
    
          # Test config
          & "C:\ngrok\ngrok.exe" config check
          Write-Output "✓ Ngrok config check passed"
    
      - name: Start Ngrok agent
        shell: pwsh
        run: |
          $ngrokDir = "C:\ngrok"
          # Đảm bảo thêm vào PATH cho phiên hiện tại
          $env:Path += ";$ngrokDir"

          # Kill any existing ngrok processes
          Get-Process -Name "ngrok" -ErrorAction SilentlyContinue | Stop-Process -Force

          # Start ngrok agent without tunnel (will create via API)
          Start-Process -FilePath "$ngrokDir\ngrok.exe" -ArgumentList "start --none --log=stdout" -WindowStyle Hidden

          # Wait for ngrok agent to be ready
          $maxWait = 30
          $waitCount = 0
          $ngrokReady = $false

          while (-not $ngrokReady -and $waitCount -lt $maxWait) {
            try {
              $response = Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -UseBasicParsing -TimeoutSec 2 -ErrorAction Stop
              if ($response.StatusCode -eq 200) {
                $ngrokReady = $true
                Write-Output "✓ Ngrok agent is ready"
                break
              }
            } catch {
              Write-Output "Waiting for ngrok agent to start... ($waitCount/$maxWait)"
              Start-Sleep -Seconds 1
              $waitCount++
            }
          }

          if (-not $ngrokReady) {
            Write-Warning "Ngrok agent not responding, but continuing anyway"
          } else {
            Write-Output "Ngrok agent started successfully"
          }

      - name: Create Ngrok tunnel via API
        shell: pwsh
        run: |
          $maxRetries = 5
          $retryCount = 0
          $tunnelCreated = $false

          # First, check if API is accessible
          Write-Output "Checking Ngrok API status..."
          try {
            $statusResponse = Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -UseBasicParsing -TimeoutSec 5
            Write-Output "✓ Ngrok API is accessible (Status: $($statusResponse.StatusCode))"
          } catch {
            Write-Output "⚠ Ngrok API not accessible: $($_.Exception.Message)"
            Write-Output "Restarting Ngrok agent..."
            Get-Process -Name "ngrok" -ErrorAction SilentlyContinue | Stop-Process -Force
            Start-Process -FilePath "C:\ngrok\ngrok.exe" -ArgumentList "start --none --log=stdout" -WindowStyle Hidden
            Start-Sleep -Seconds 10
          }

          while (-not $tunnelCreated -and $retryCount -lt $maxRetries) {
            try {
              Write-Output "Attempt $($retryCount + 1) to create tunnel via API..."

              $tunnelConfig = @{
                name = "vnc-tunnel"
                proto = "tcp"
                addr = "5900"
              } | ConvertTo-Json

              Write-Output "Tunnel config: $tunnelConfig"

              $response = Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -Method POST -Body $tunnelConfig -ContentType "application/json" -UseBasicParsing -TimeoutSec 15

              if ($response.StatusCode -eq 201) {
                Write-Output "✓ Ngrok tunnel created successfully via API"
                $tunnelCreated = $true
              } else {
                Write-Output "Unexpected status code: $($response.StatusCode)"
              }
            } catch {
              $retryCount++
              $errorMsg = $_.Exception.Message
              Write-Output "Failed to create tunnel (attempt $retryCount): $errorMsg"

              # If it's a 502 error, try restarting the agent
              if ($errorMsg -like "*502*" -or $errorMsg -like "*Bad Gateway*") {
                Write-Output "502 error detected, restarting Ngrok agent..."
                Get-Process -Name "ngrok" -ErrorAction SilentlyContinue | Stop-Process -Force
                Start-Sleep -Seconds 2
                Start-Process -FilePath "C:\ngrok\ngrok.exe" -ArgumentList "start --none --log=stdout" -WindowStyle Hidden
                Start-Sleep -Seconds 8
              } else {
                Start-Sleep -Seconds 2
              }
            }
          }

          if (-not $tunnelCreated) {
            Write-Output "API method failed, falling back to direct tunnel creation..."
            try {
              # Fallback: Kill existing and start with direct tunnel
              Get-Process -Name "ngrok" -ErrorAction SilentlyContinue | Stop-Process -Force
              Start-Sleep -Seconds 2

              # Start ngrok with direct tunnel creation
              Start-Process -FilePath "C:\ngrok\ngrok.exe" -ArgumentList "tcp 5900 --log=stdout" -WindowStyle Hidden
              Write-Output "Started ngrok with direct tunnel creation"

              # Wait for tunnel to be established
              $maxWait = 30
              $waitCount = 0
              $tunnelReady = $false

              while (-not $tunnelReady -and $waitCount -lt $maxWait) {
                try {
                  $verifyResponse = Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -UseBasicParsing -TimeoutSec 5
                  $tunnels = ($verifyResponse.Content | ConvertFrom-Json).tunnels
                  if ($tunnels.Count -gt 0) {
                    $tunnelReady = $true
                    Write-Output "✓ Fallback tunnel created successfully"
                    break
                  }
                } catch {
                  Write-Output "Waiting for direct tunnel... ($waitCount/$maxWait)"
                }
                Start-Sleep -Seconds 1
                $waitCount++
              }

              if (-not $tunnelReady) {
                throw "Direct tunnel creation timed out"
              }
            } catch {
              Write-Error "Both API and direct tunnel methods failed: $($_.Exception.Message)"
              Write-Output "Please check your NGROK_AUTH_TOKEN secret and ensure it's valid."
              exit 1
            }
          }

      - name: Get Ngrok connection info
        shell: pwsh
        run: |
          $maxRetries = 10
          $retryCount = 0
          $success = $false
    
          # Thêm ngrok vào PATH cho step này
          $env:Path += ";C:\ngrok"
    
          while (-not $success -and $retryCount -lt $maxRetries) {
            try {
              Write-Output "Attempt $($retryCount + 1) to get ngrok info..."

              # Kiểm tra ngrok process
              $ngrokProcess = Get-Process -Name "ngrok" -ErrorAction SilentlyContinue
              if (-not $ngrokProcess) {
                Write-Output "Ngrok process not found, restarting agent..."
                Start-Process -FilePath "C:\ngrok\ngrok.exe" -ArgumentList "start --none --log=stdout" -WindowStyle Hidden
                Start-Sleep -Seconds 5

                # Recreate tunnel via API
                $tunnelConfig = @{
                  name = "vnc-tunnel"
                  proto = "tcp"
                  addr = "5900"
                } | ConvertTo-Json

                Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -Method POST -Body $tunnelConfig -ContentType "application/json" -UseBasicParsing -TimeoutSec 10 | Out-Null
                Start-Sleep -Seconds 3
              }

              $ngrokInfo = (Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -UseBasicParsing -TimeoutSec 5).Content | ConvertFrom-Json

              # Try to find the named tunnel first (API created), then fallback to any TCP tunnel
              $vncTunnel = $ngrokInfo.tunnels | Where-Object { $_.name -eq "vnc-tunnel" }
              if (-not $vncTunnel) {
                # Fallback: look for any TCP tunnel
                $vncTunnel = $ngrokInfo.tunnels | Where-Object { $_.proto -eq "tcp" } | Select-Object -First 1
                if (-not $vncTunnel) {
                  throw "No TCP tunnel found"
                }
                Write-Output "Using fallback tunnel (direct creation)"
              } else {
                Write-Output "Using API-created tunnel"
              }

              $vncUrl = $vncTunnel.public_url
              $vncHost = $vncUrl -replace "tcp://", ""
              $vncHost, $vncPort = $vncHost -split ":"

              Write-Output "✓ Ngrok tunnel active: $vncUrl"

              echo "vnc_url=$vncUrl" >> $env:GITHUB_OUTPUT
              echo "vnc_host=$vncHost" >> $env:GITHUB_OUTPUT
              echo "vnc_port=$vncPort" >> $env:GITHUB_OUTPUT
              echo "connection_method=ngrok" >> $env:GITHUB_OUTPUT

              $success = $true

            } catch {
              $retryCount++
              $errorMsg = $_.Exception.Message
              Write-Output "Attempt $retryCount failed: $errorMsg"

              # Nếu là lỗi connection refused, thử restart ngrok
              if ($errorMsg -like "*actively refused*" -or $errorMsg -like "*cannot connect*") {
                Write-Output "Restarting ngrok agent..."
                Get-Process -Name "ngrok" -ErrorAction SilentlyContinue | Stop-Process -Force
                Start-Sleep -Seconds 2
                Start-Process -FilePath "C:\ngrok\ngrok.exe" -ArgumentList "start --none --log=stdout" -WindowStyle Hidden
                Start-Sleep -Seconds 5

                # Recreate tunnel
                try {
                  $tunnelConfig = @{
                    name = "vnc-tunnel"
                    proto = "tcp"
                    addr = "5900"
                  } | ConvertTo-Json

                  Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -Method POST -Body $tunnelConfig -ContentType "application/json" -UseBasicParsing -TimeoutSec 10 | Out-Null
                } catch {
                  Write-Output "Failed to recreate tunnel: $($_.Exception.Message)"
                }
              }

              Start-Sleep -Seconds 3
            }
          }
    
          if (-not $success) {
            Write-Output "Failed to get Ngrok connection info after $maxRetries attempts, using direct connection fallback"
            try {
              $publicIP = (Invoke-WebRequest -Uri "https://api.ipify.org" -UseBasicParsing -TimeoutSec 10).Content
              Write-Output "Public IP: $publicIP"
              echo "vnc_url=tcp://$publicIP:5900" >> $env:GITHUB_OUTPUT
              echo "vnc_host=$publicIP" >> $env:GITHUB_OUTPUT
              echo "vnc_port=5900" >> $env:GITHUB_OUTPUT
              echo "connection_method=direct" >> $env:GITHUB_OUTPUT
            } catch {
              Write-Output "Could not retrieve public IP either"
              echo "connection_method=failed" >> $env:GITHUB_OUTPUT
            }
          }
        id: connection_info

      - name: Display connection info
        shell: pwsh
        run: |
          Write-Output "=== VNC CONNECTION INFORMATION ==="
          
          if ("${{ steps.connection_info.outputs.connection_method }}" -eq "ngrok") {
            Write-Output "Connection Method: Ngrok Tunnel"
            Write-Output "URL: ${{ steps.connection_info.outputs.vnc_url }}"
            Write-Output "Host: ${{ steps.connection_info.outputs.vnc_host }}"
            Write-Output "Port: ${{ steps.connection_info.outputs.vnc_port }}"
          } elseif ("${{ steps.connection_info.outputs.connection_method }}" -eq "direct") {
            Write-Output "Connection Method: Direct Connection"
            Write-Output "Host: ${{ steps.connection_info.outputs.vnc_host }}"
            Write-Output "Port: ${{ steps.connection_info.outputs.vnc_port }}"
            Write-Output "Note: Direct connection may be blocked by firewall"
          } else {
            Write-Output "Connection Method: Failed to establish"
            Write-Output "Please check the workflow logs for details"
          }
          
          Write-Output "Password: ***"
          Write-Output "Username: ${{ env.WINDOWS_USER }}"
          Write-Output "=================================="
          
          $connectionGuide = @"
          # Hướng dẫn kết nối VNC

          ## Thông tin kết nối:
          ${{ steps.connection_info.outputs.vnc_url }}

          ## Hướng dẫn RealVNC:
          1. Mở RealVNC Viewer
          2. Nhập địa chỉ: ${{ steps.connection_info.outputs.vnc_url }}
          3. Nhập password khi được yêu cầu
          4. Username: ${{ env.WINDOWS_USER }}

          ## Lưu ý:
          - Kết nối sẽ tự động đóng sau 6 giờ
          - Dữ liệu sẽ được backup tự động
          "@
          
          $connectionGuide | Out-File -FilePath "C:\connection_guide.txt" -Encoding UTF8

      - name: Keep alive for 6 hours
        shell: pwsh
        run: |
          Write-Output "Remote desktop will be available for 6 hours"
          
          $keepAliveScript = @"
          `$duration = 6 * 60 * 60
          `$startTime = Get-Date
          `$checkInterval = 300
          
          while (((Get-Date) - `$startTime).TotalSeconds -lt `$duration) {
              `$elapsed = [math]::Round(((Get-Date) - `$startTime).TotalSeconds)
              `$remaining = `$duration - `$elapsed
              `$hours = [math]::Floor(`$remaining / 3600)
              `$minutes = [math]::Floor((`$remaining % 3600) / 60)
              
              Write-Output "Time remaining: `${hours}h `${minutes}m"
              
              # Kiểm tra VNC service
              try {
                  `$vncService = Get-Service -Name "tvnserver" -ErrorAction Stop
                  if (`$vncService.Status -ne "Running") {
                      Start-Service -Name "tvnserver"
                      Write-Output "Restarted TightVNC service"
                  }
              } catch {
                  Write-Output "VNC service issue: `$(`$_.Exception.Message)"
              }
              
              # Kiểm tra Ngrok
              try {
                  `$ngrokProcess = Get-Process -Name "ngrok" -ErrorAction Stop
                  `$tunnelActive = `$true
                  try {
                      `$ngrokInfo = (Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -UseBasicParsing -TimeoutSec 10).Content | ConvertFrom-Json
                      # Check for named tunnel first, then any TCP tunnel
                      `$vncTunnel = `$ngrokInfo.tunnels | Where-Object { `$_.name -eq "vnc-tunnel" }
                      if (-not `$vncTunnel) {
                          `$vncTunnel = `$ngrokInfo.tunnels | Where-Object { `$_.proto -eq "tcp" } | Select-Object -First 1
                      }
                      if (-not `$vncTunnel) {
                          `$tunnelActive = `$false
                      }
                  } catch {
                      `$tunnelActive = `$false
                  }

                  if (-not `$tunnelActive) {
                      Write-Output "VNC tunnel not found, recreating..."
                      try {
                          `$tunnelConfig = @{
                              name = "vnc-tunnel"
                              proto = "tcp"
                              addr = "5900"
                          } | ConvertTo-Json

                          Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -Method POST -Body `$tunnelConfig -ContentType "application/json" -UseBasicParsing -TimeoutSec 10 | Out-Null
                          Write-Output "Recreated Ngrok tunnel via API"
                          Start-Sleep -Seconds 3
                      } catch {
                          Write-Output "Failed to recreate tunnel: `$(`$_.Exception.Message)"
                          # Restart agent if API fails
                          Stop-Process -Name "ngrok" -Force -ErrorAction SilentlyContinue
                          Start-Process -FilePath "ngrok" -ArgumentList "start --none --log=stdout" -WindowStyle Hidden
                          Start-Sleep -Seconds 5
                          # Recreate tunnel
                          `$tunnelConfig = @{
                              name = "vnc-tunnel"
                              proto = "tcp"
                              addr = "5900"
                          } | ConvertTo-Json
                          Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -Method POST -Body `$tunnelConfig -ContentType "application/json" -UseBasicParsing -TimeoutSec 10 | Out-Null
                      }
                  }
              } catch {
                  Write-Output "Ngrok process not found, restarting agent..."
                  Start-Process -FilePath "ngrok" -ArgumentList "start --none --log=stdout" -WindowStyle Hidden
                  Start-Sleep -Seconds 5
                  # Create tunnel
                  `$tunnelConfig = @{
                      name = "vnc-tunnel"
                      proto = "tcp"
                      addr = "5900"
                  } | ConvertTo-Json
                  Invoke-WebRequest -Uri "http://localhost:4040/api/tunnels" -Method POST -Body `$tunnelConfig -ContentType "application/json" -UseBasicParsing -TimeoutSec 10 | Out-Null
                  Write-Output "Started Ngrok agent and created tunnel"
                  Start-Sleep -Seconds 3
              }
              
              Start-Sleep -Seconds `$checkInterval
          }
          
          Write-Output "Session completed"
          "@
          
          $keepAliveScript | Out-File -FilePath "C:\keep-alive.ps1" -Encoding UTF8
          & "C:\keep-alive.ps1"

      - name: Create backup
        shell: pwsh
        run: |
          $backupFolders = @(
            "$env:USERPROFILE\AppData",
            "$env:USERPROFILE\Documents", 
            "$env:USERPROFILE\Downloads",
            "$env:USERPROFILE\LocalAppData"
          )
          Compress-Archive -Path $backupFolders -DestinationPath "C:\backup.zip" -CompressionLevel Optimal -Force
          Write-Output "Backup created successfully"

      - name: Upload backup to artifact
        uses: actions/upload-artifact@v4.3.1
        with:
          name: windows-backup
          path: C:\backup.zip
          retention-days: 7

      - name: Cleanup
        shell: pwsh
        run: |
          Stop-Service -Name "tvnserver" -ErrorAction SilentlyContinue
          Get-Process | Where-Object { $_.Name -like "*ngrok*" } | Stop-Process -Force -ErrorAction SilentlyContinue
          
          Remove-Item -Path "C:\backup.zip", "C:\keep-alive.ps1", "C:\connection_guide.txt", "C:\ngrok.zip" -Force -ErrorAction SilentlyContinue
          Remove-Item -Path "C:\ngrok" -Recurse -Force -ErrorAction SilentlyContinue
          
          Write-Output "Cleanup completed"
