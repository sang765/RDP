name: Windows VNC Remote Desktop
run-name: Windows VNC Session by ${{ github.actor }}

on:
  workflow_dispatch:

permissions:
  contents: write
  actions: write
  packages: write

env:
  VNC_PASSWORD: ${{ secrets.VNC_PASSWORD }}
  WINDOWS_USER: ${{ secrets.WINDOWS_USER || 'githubrunner' }}

jobs:
  setup-windows-vnc:
    runs-on: windows-latest
    timeout-minutes: 420

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4.1.1

      - name: Mask sensitive values
        shell: pwsh
        run: |
          echo "::add-mask::${{ secrets.VNC_PASSWORD }}"
          echo "::add-mask::${{ secrets.PAT }}"

      - name: Get previous successful workflow run ID
        id: get_previous_run
        shell: pwsh
        run: |
          $url = "https://api.github.com/repos/${{ github.repository }}/actions/runs?status=success&event=workflow_dispatch&per_page=1"
          $headers = @{
            'Authorization' = "token ${{ secrets.PAT }}"
            'Accept'        = 'application/vnd.github.v3+json'
          }
          try {
            $response = Invoke-RestMethod -Uri $url -Headers $headers -Method Get
            if ($response.workflow_runs.Count -gt 0) {
              $runId = $response.workflow_runs[0].id
              Write-Output "Previous successful run ID: $runId"
              echo "prev_run_id=$runId" >> $env:GITHUB_OUTPUT
            } else {
              Write-Output "No previous successful run found."
              echo "prev_run_id=0" >> $env:GITHUB_OUTPUT
            }
          } catch {
            Write-Output "Error fetching previous run: $($_.Exception.Message)"
            echo "prev_run_id=0" >> $env:GITHUB_OUTPUT
          }
        env:
          PAT: ${{ secrets.PAT }}

      - name: Download backup from previous run
        uses: actions/download-artifact@v4.1.1
        with:
          name: windows-backup
          run-id: ${{ steps.get_previous_run.outputs.prev_run_id }}
          path: C:\
        continue-on-error: true

      - name: Restore backup
        shell: pwsh
        run: |
          if (Test-Path "C:\backup.zip") {
            Expand-Archive -Path "C:\backup.zip" -DestinationPath "C:\" -Force
            Remove-Item "C:\backup.zip" -Force
            Write-Output "Backup restored successfully"
          } else {
            Write-Output "No backup found, starting fresh"
          }

      - name: Create local admin user
        shell: pwsh
        run: |
          $username = "$env:WINDOWS_USER"
          
          if (-not (Get-LocalUser -Name $username -ErrorAction SilentlyContinue)) {
            $password = ConvertTo-SecureString "SecurePassword123!" -AsPlainText -Force
            New-LocalUser -Name $username -Password $password -FullName "GitHub Runner" -Description "Temporary admin user for VNC"
            Add-LocalGroupMember -Group "Administrators" -Member $username
            Write-Output "Created user: $username"
          } else {
            Write-Output "User $username already exists"
          }

      - name: Disable Windows Firewall
        shell: pwsh
        run: |
          Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False

      - name: Disable Windows Defender Firewall
        shell: pwsh
        run: |
          try {
              # Disable Windows Defender Firewall for all profiles
              Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False -ErrorAction Stop
              Write-Output "Windows Defender Firewall disabled successfully"
          } catch {
              Write-Output "Windows Defender Firewall disable failed: $($_.Exception.Message)"
              # Try alternative method
              try {
                  netsh advfirewall set allprofiles state off
                  Write-Output "Windows Defender Firewall disabled via netsh"
              } catch {
                  Write-Output "Alternative firewall disable also failed: $($_.Exception.Message)"
              }
          }

          # Also disable Windows Defender real-time protection temporarily
          try {
              Set-MpPreference -DisableRealtimeMonitoring $true -ErrorAction Stop
              Write-Output "Windows Defender real-time protection disabled"
          } catch {
              Write-Output "Failed to disable Windows Defender real-time protection: $($_.Exception.Message)"
          }

      - name: Install TightVNC
        shell: pwsh
        run: |
          try {
            choco install tightvnc -y --force
            Write-Output "TightVNC installed successfully via Chocolatey"
          } catch {
            Write-Error "Failed to install TightVNC: $($_.Exception.Message)"
            exit 1
          }

      - name: Set VNC password
        shell: pwsh
        env:
          VNC_PASSWORD: "${{ secrets.VNC_PASSWORD }}"
        run: |
          $vncPasswdPath = "$env:ProgramFiles\TightVNC\tvnserver.exe"
          if (Test-Path $vncPasswdPath) {
            & "$vncPasswdPath" -controlservice -password $env:VNC_PASSWORD
            Write-Output "VNC password set successfully"
          } else {
            $altPath = "${env:ProgramFiles(x86)}\TightVNC\tvnserver.exe"
            if (Test-Path $altPath) {
              & "$altPath" -controlservice -password $env:VNC_PASSWORD
              Write-Output "VNC password set successfully from alternative path"
            } else {
              Write-Error "TightVNC not found"
            }
          }

      - name: Configure TightVNC Server
        shell: pwsh
        run: |
          $vncServerPath = "$env:ProgramFiles\TightVNC\tvnserver.exe"
          if (Test-Path $vncServerPath) {
            & "$vncServerPath" -install -silent
            & "$vncServerPath" -controlservice -sharedisplay 1
            & "$vncServerPath" -controlservice -allowloopback 1
            Write-Output "TightVNC service installed and configured"
          } else {
            $altPath = "${env:ProgramFiles(x86)}\TightVNC\tvnserver.exe"
            if (Test-Path $altPath) {
              & "$altPath" -install -silent
              & "$altPath" -controlservice -sharedisplay 1
              & "$altPath" -controlservice -allowloopback 1
              Write-Output "TightVNC service installed from alternative path"
            } else {
              Write-Error "TightVNC not found"
            }
          }

      - name: Start TightVNC Server
        shell: pwsh
        run: |
          try {
            Start-Service -Name "tvnserver"
            Start-Sleep -Seconds 5
            $service = Get-Service -Name "tvnserver"
            if ($service.Status -eq "Running") {
              Write-Output "TightVNC server started successfully"
            } else {
              Write-Error "TightVNC service failed to start"
            }
          } catch {
            Write-Error "Failed to start TightVNC service: $($_.Exception.Message)"
          }

      - name: Test VNC connection locally
        shell: pwsh
        run: |
          try {
            $tcpClient = New-Object System.Net.Sockets.TcpClient
            $result = $tcpClient.BeginConnect("127.0.0.1", 5900, $null, $null)
            $success = $result.AsyncWaitHandle.WaitOne(5000)
            if ($success) {
              $tcpClient.EndConnect($result)
              Write-Output "VNC server is responding on localhost"
              echo "vnc_local_test=success" >> $env:GITHUB_OUTPUT
            } else {
              Write-Output "VNC server is not responding on localhost"
              echo "vnc_local_test=failed" >> $env:GITHUB_OUTPUT
            }
            $tcpClient.Close()
          } catch {
            Write-Output "Error testing VNC connection: $($_.Exception.Message)"
            echo "vnc_local_test=error" >> $env:GITHUB_OUTPUT
          }
        id: vnc_test

      - name: Install Cloudflare Tunnel
        shell: pwsh
        run: |
          try {
              $cloudflaredDir = "C:\cloudflared"

              # Download cloudflared
              Write-Output "Downloading cloudflared..."
              Invoke-WebRequest -Uri "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe" -OutFile "C:\cloudflared.exe" -TimeoutSec 30

              # Create directory and move executable
              New-Item -ItemType Directory -Path $cloudflaredDir -Force
              Move-Item -Path "C:\cloudflared.exe" -Destination "$cloudflaredDir\cloudflared.exe" -Force

              # Add to PATH
              $env:Path += ";$cloudflaredDir"

              # Verify installation
              if (Test-Path "$cloudflaredDir\cloudflared.exe") {
                  Write-Output "Cloudflared installed successfully"
                  # Test version
                  & "$cloudflaredDir\cloudflared.exe" --version
              } else {
                  throw "Cloudflared executable not found"
              }
          } catch {
              Write-Error "Failed to install Cloudflared: $($_.Exception.Message)"
              exit 1
          }
          
      - name: Verify Ngrok installation
        shell: pwsh
        run: |
          $ngrokDir = "C:\ngrok"
          if (Test-Path "$ngrokDir\ngrok.exe") {
              Write-Output "✓ Ngrok executable found"
              # Test chạy ngrok version
              & "$ngrokDir\ngrok.exe" --version
              Write-Output "✓ Ngrok version check passed"
          } else {
              Write-Error "✗ Ngrok executable not found"
              exit 1
          }

      - name: Configure Cloudflare Tunnel
        shell: pwsh
        run: |
          # Add cloudflared to PATH
          $cloudflaredDir = "C:\cloudflared"
          $env:Path += ";$cloudflaredDir"

          # Verify cloudflared installation
          if (Test-Path "$cloudflaredDir\cloudflared.exe") {
              Write-Output "Cloudflared found at: $cloudflaredDir\cloudflared.exe"

              # Test cloudflared
              & "$cloudflaredDir\cloudflared.exe" version
              Write-Output "Cloudflared is ready to create tunnels"

          } else {
              Write-Error "Cloudflared executable not found in $cloudflaredDir"
              exit 1
          }

      
      - name: Create Cloudflare Tunnel
        shell: pwsh
        run: |
          $cloudflaredDir = "C:\cloudflared"
          $env:Path += ";$cloudflaredDir"

          # Kill any existing cloudflared processes
          Get-Process -Name "cloudflared" -ErrorAction SilentlyContinue | Stop-Process -Force

          Write-Output "Starting Cloudflare tunnel for VNC port 5900..."

          # Start cloudflared tunnel
          # This will create a tunnel accessible via trycloudflare.com
          Start-Process -FilePath "$cloudflaredDir\cloudflared.exe" -ArgumentList "tunnel --url tcp://localhost:5900 --logfile C:\cloudflared.log" -WindowStyle Hidden -RedirectStandardOutput "C:\cloudflared_output.txt"

          Write-Output "Cloudflared tunnel started, waiting for connection URL..."

          # Wait for the tunnel to establish and get the URL
          $maxWait = 30
          $waitCount = 0
          $tunnelReady = $false
          $connectionUrl = $null

          while (-not $tunnelReady -and $waitCount -lt $maxWait) {
            try {
              # Check if output file exists and contains the URL
              if (Test-Path "C:\cloudflared_output.txt") {
                $output = Get-Content "C:\cloudflared_output.txt" -Raw
                # Look for the cloudflare URL in the output
                $urlMatch = $output | Select-String -Pattern "https://[^\s]+\.trycloudflare\.com" -AllMatches
                if ($urlMatch.Matches.Count -gt 0) {
                  $connectionUrl = $urlMatch.Matches[0].Value
                  $tunnelReady = $true
                  Write-Output "✓ Cloudflare tunnel established!"
                  Write-Output "Connection URL: $connectionUrl"
                  break
                }
              }

              # Also check the log file
              if (Test-Path "C:\cloudflared.log") {
                $logContent = Get-Content "C:\cloudflared.log" -Raw
                $urlMatch = $logContent | Select-String -Pattern "https://[^\s]+\.trycloudflare\.com" -AllMatches
                if ($urlMatch.Matches.Count -gt 0) {
                  $connectionUrl = $urlMatch.Matches[0].Value
                  $tunnelReady = $true
                  Write-Output "✓ Cloudflare tunnel established!"
                  Write-Output "Connection URL: $connectionUrl"
                  break
                }
              }
            } catch {
              # Ignore errors and continue waiting
            }

            if ($waitCount % 5 -eq 0) {
              Write-Output "Waiting for tunnel... ($waitCount/$maxWait)"
            }

            Start-Sleep -Seconds 1
            $waitCount++
          }

          if (-not $tunnelReady) {
            Write-Output "Tunnel creation timed out, but continuing anyway..."
            Write-Output "Check C:\cloudflared.log for connection details"
          }

          # Save connection URL for later steps
          if ($connectionUrl) {
            $connectionUrl | Out-File -FilePath "C:\tunnel_url.txt" -Encoding UTF8
          }

      - name: Get Cloudflare connection info
        shell: pwsh
        run: |
          Write-Output "Retrieving Cloudflare tunnel connection information..."

          $connectionUrl = $null

          # First, try to read from the saved file
          if (Test-Path "C:\tunnel_url.txt") {
            $connectionUrl = Get-Content "C:\tunnel_url.txt" -Raw
            Write-Output "Found saved connection URL: $connectionUrl"
          }

          # If not found, try to extract from log files
          if (-not $connectionUrl) {
            try {
              if (Test-Path "C:\cloudflared.log") {
                $logContent = Get-Content "C:\cloudflared.log" -Raw
                $urlMatch = $logContent | Select-String -Pattern "https://[^\s]+\.trycloudflare\.com" -AllMatches
                if ($urlMatch.Matches.Count -gt 0) {
                  $connectionUrl = $urlMatch.Matches[0].Value
                  Write-Output "Found connection URL in log: $connectionUrl"
                }
              }
            } catch {
              Write-Output "Could not read log file: $($_.Exception.Message)"
            }
          }

          # If still not found, try output file
          if (-not $connectionUrl) {
            try {
              if (Test-Path "C:\cloudflared_output.txt") {
                $outputContent = Get-Content "C:\cloudflared_output.txt" -Raw
                $urlMatch = $outputContent | Select-String -Pattern "https://[^\s]+\.trycloudflare\.com" -AllMatches
                if ($urlMatch.Matches.Count -gt 0) {
                  $connectionUrl = $urlMatch.Matches[0].Value
                  Write-Output "Found connection URL in output: $connectionUrl"
                }
              }
            } catch {
              Write-Output "Could not read output file: $($_.Exception.Message)"
            }
          }

          # If we have a connection URL, parse it
          if ($connectionUrl) {
            Write-Output "✓ Cloudflare tunnel connection established"
            Write-Output "Connection URL: $connectionUrl"

            # For cloudflared, the URL is typically https://xxxxx.trycloudflare.com
            # But for VNC (TCP), we need to convert it to the proper format
            $vncUrl = $connectionUrl -replace "https://", "tcp://"

            echo "vnc_url=$vncUrl" >> $env:GITHUB_OUTPUT
            echo "vnc_host=$($connectionUrl -replace 'https://', '')" >> $env:GITHUB_OUTPUT
            echo "vnc_port=5900" >> $env:GITHUB_OUTPUT
            echo "connection_method=cloudflare" >> $env:GITHUB_OUTPUT

          } else {
            Write-Output "Could not find Cloudflare connection URL, using fallback"
            try {
              $publicIP = (Invoke-WebRequest -Uri "https://api.ipify.org" -UseBasicParsing -TimeoutSec 10).Content
              Write-Output "Public IP fallback: $publicIP"
              echo "vnc_url=tcp://$publicIP:5900" >> $env:GITHUB_OUTPUT
              echo "vnc_host=$publicIP" >> $env:GITHUB_OUTPUT
              echo "vnc_port=5900" >> $env:GITHUB_OUTPUT
              echo "connection_method=direct" >> $env:GITHUB_OUTPUT
            } catch {
              Write-Output "Could not retrieve public IP either"
              echo "connection_method=failed" >> $env:GITHUB_OUTPUT
            }
          }
        id: connection_info

      - name: Display connection info
        shell: pwsh
        run: |
          Write-Output "=== VNC CONNECTION INFORMATION ==="
          
          if ("${{ steps.connection_info.outputs.connection_method }}" -eq "cloudflare") {
            Write-Output "Connection Method: Cloudflare Tunnel"
            Write-Output "URL: ${{ steps.connection_info.outputs.vnc_url }}"
            Write-Output "Host: ${{ steps.connection_info.outputs.vnc_host }}"
            Write-Output "Port: ${{ steps.connection_info.outputs.vnc_port }}"
            Write-Output "Note: Use the HTTPS URL in your VNC client"
          } elseif ("${{ steps.connection_info.outputs.connection_method }}" -eq "direct") {
            Write-Output "Connection Method: Direct Connection"
            Write-Output "Host: ${{ steps.connection_info.outputs.vnc_host }}"
            Write-Output "Port: ${{ steps.connection_info.outputs.vnc_port }}"
            Write-Output "Note: Direct connection may be blocked by firewall"
          } else {
            Write-Output "Connection Method: Failed to establish"
            Write-Output "Please check the workflow logs for details"
          }
          
          Write-Output "Password: ***"
          Write-Output "Username: ${{ env.WINDOWS_USER }}"
          Write-Output "=================================="
          
          $connectionGuide = @"
          # Hướng dẫn kết nối VNC

          ## Thông tin kết nối:
          ${{ steps.connection_info.outputs.vnc_url }}

          ## Hướng dẫn RealVNC:
          1. Mở RealVNC Viewer
          2. Nhập địa chỉ: ${{ steps.connection_info.outputs.vnc_url }}
          3. Nhập password khi được yêu cầu
          4. Username: ${{ env.WINDOWS_USER }}
          5. Note: Cloudflare tunnel may take a moment to connect

          ## Lưu ý:
          - Kết nối sẽ tự động đóng sau 6 giờ
          - Dữ liệu sẽ được backup tự động
          "@
          
          $connectionGuide | Out-File -FilePath "C:\connection_guide.txt" -Encoding UTF8

      - name: Keep alive for 6 hours
        shell: pwsh
        run: |
          Write-Output "Remote desktop will be available for 6 hours"
          
          $keepAliveScript = @"
          `$duration = 6 * 60 * 60
          `$startTime = Get-Date
          `$checkInterval = 300
          
          while (((Get-Date) - `$startTime).TotalSeconds -lt `$duration) {
              `$elapsed = [math]::Round(((Get-Date) - `$startTime).TotalSeconds)
              `$remaining = `$duration - `$elapsed
              `$hours = [math]::Floor(`$remaining / 3600)
              `$minutes = [math]::Floor((`$remaining % 3600) / 60)
              
              Write-Output "Time remaining: `${hours}h `${minutes}m"
              
              # Kiểm tra VNC service
              try {
                  `$vncService = Get-Service -Name "tvnserver" -ErrorAction Stop
                  if (`$vncService.Status -ne "Running") {
                      Start-Service -Name "tvnserver"
                      Write-Output "Restarted TightVNC service"
                  }
              } catch {
                  Write-Output "VNC service issue: `$(`$_.Exception.Message)"
              }
              
              # Kiểm tra Cloudflared
              try {
                  `$cloudflaredProcess = Get-Process -Name "cloudflared" -ErrorAction Stop
                  Write-Output "Cloudflared process is running"

                  # Check if tunnel URL is still accessible
                  if (Test-Path "C:\tunnel_url.txt") {
                      `$savedUrl = Get-Content "C:\tunnel_url.txt" -Raw
                      Write-Output "Tunnel URL still saved: `$savedUrl"
                  } else {
                      Write-Output "Tunnel URL file missing, tunnel may have disconnected"
                  }
              } catch {
                  Write-Output "Cloudflared process not found, restarting tunnel..."
                  try {
                      # Restart cloudflared tunnel
                      Start-Process -FilePath "C:\cloudflared\cloudflared.exe" -ArgumentList "tunnel --url tcp://localhost:5900 --logfile C:\cloudflared.log" -WindowStyle Hidden -RedirectStandardOutput "C:\cloudflared_output.txt"
                      Write-Output "Restarted Cloudflared tunnel"
                      Start-Sleep -Seconds 10

                      # Try to get the new URL
                      if (Test-Path "C:\cloudflared_output.txt") {
                          `$output = Get-Content "C:\cloudflared_output.txt" -Raw
                          `$urlMatch = `$output | Select-String -Pattern "https://[^\s]+\.trycloudflare\.com" -AllMatches
                          if (`$urlMatch.Matches.Count -gt 0) {
                              `$newUrl = `$urlMatch.Matches[0].Value
                              `$newUrl | Out-File -FilePath "C:\tunnel_url.txt" -Encoding UTF8
                              Write-Output "New tunnel URL saved: `$newUrl"
                          }
                      }
                  } catch {
                      Write-Output "Failed to restart Cloudflared: `$(`$_.Exception.Message)"
                  }
              }
              
              Start-Sleep -Seconds `$checkInterval
          }
          
          Write-Output "Session completed"
          "@
          
          $keepAliveScript | Out-File -FilePath "C:\keep-alive.ps1" -Encoding UTF8
          & "C:\keep-alive.ps1"

      - name: Create backup
        shell: pwsh
        run: |
          $backupFolders = @(
            "$env:USERPROFILE\AppData",
            "$env:USERPROFILE\Documents", 
            "$env:USERPROFILE\Downloads",
            "$env:USERPROFILE\LocalAppData"
          )
          Compress-Archive -Path $backupFolders -DestinationPath "C:\backup.zip" -CompressionLevel Optimal -Force
          Write-Output "Backup created successfully"

      - name: Upload backup to artifact
        uses: actions/upload-artifact@v4.3.1
        with:
          name: windows-backup
          path: C:\backup.zip
          retention-days: 7

      - name: Cleanup
        shell: pwsh
        run: |
          Stop-Service -Name "tvnserver" -ErrorAction SilentlyContinue
          Get-Process | Where-Object { $_.Name -like "*cloudflared*" } | Stop-Process -Force -ErrorAction SilentlyContinue

          Remove-Item -Path "C:\backup.zip", "C:\keep-alive.ps1", "C:\connection_guide.txt", "C:\cloudflared_output.txt", "C:\cloudflared.log", "C:\tunnel_url.txt" -Force -ErrorAction SilentlyContinue
          Remove-Item -Path "C:\cloudflared" -Recurse -Force -ErrorAction SilentlyContinue
          
          Write-Output "Cleanup completed"
